# DataBase(데이터베이스)

</br>

## 데이터베이스 vs 파일 시스템

### 파일 시스템(File System)

- data의 정의가 Application Program에 내포한다.
- 프로그램에서 데이터 접근하고 조작하는 것 이외에는 별도의 제어가 없다.

##### 단점
- 데이터간 불일치 발생
	- 중복된 데이터의 변경을 제어하는 것이 어렵다.
- 다수 사용자를 위한 동시성 제어가 제공안된다.
	- 동기화가 되지 않는다.
- 쉬운 쿼리 언어를 제공하지 않는다
- recovery 기능 없다.
- 응용프로그램에서 file 내의 데이터를 수정하는 도중에 강제종료등의 상황에 대처 기능이 없다.
- 데이터의 독립성이 없어서 유지 보수 비용이크다.
	- 파일 구조변경시 독립적이지 않아 종속적이므로 모든 응용프로그램을 수정해야한다.
- 데이터 모델링 개념 부족
- 데이터 무결성 유지가 힘들다.
	- 새로운 제약이 추가,수정,제거가 쉽지가 않다.
- 데이터 공유의 어려움이 있어 생산성이 낮다.

</br>

### 데이터베이스 시스템(DataBase System)

위의 파일 시스템의 단점을 보완해서 나왔다. (현재도 부분적으로 사용하고 있지만) 데이터를 파일 단위로 저장하며 이러한 일들을 처리하기 위한 **독립적인 응용프로그램과 상호 연동이 되어야한다.** 이때의 문제점은 데이터 종속성 문제와 데이터 무결성이다.


#### 데이터베이스의 특징

1. 데이터의 독립성
	- 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용프로그램을 수정할 필요가 없다.
    - 논리적 독립성: 데이터베이는 논리적인 구조로 다양한 응용프로그램의 논리적 요구를 만족시켜줄 수있다.
    
2. 데이터의 무결성  
	여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

3. 데이터의 보완성  
	연관된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
    
4. 데이터의 일관성  
	연관된 정보를 논리적인 구조로 관리 함으로써 어떤 하나의 데이터만 변경 했을 경우발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제 할 수 있다.
    
5. 데이터 중복 최소화  
	- 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.
    
> Q) 무결성에 대해서 서술해보세요.

A) 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 데이터의 무결성을 유지하기 위해 DBMS에서는 크게 4가지 종류로 구분한다. 

- 엔티티 무결성 : 어떠한 기본키 값도 NULL 값이 될 수 없다.
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다.(Tuple 끼리 참조 될려면 반드시 그 Tuble이 존재해야한다)
- 도메인 무결성 : 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력되었는지 체크한다.
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유한 값을 가진다.
- NULL 무결성 : 특정 속성값에 NULL 이 올 수 없다는 조건이 주어진 경우 그 속성값은 NULL이 될 수 없다는 제약조건이다.
- Key 무결성 : 한 릴레이션에 최소한 하나의 키가 존재해야하는 제약조건, 중복을 허용하면 안되고 오직 하나의 key값은 하나의 Tuple 만 가져야한다.

> Q) 무결성을 유지하려는 이유는 무엇인가?

A) 무결성이 유지가 되어야 DB에 저장된 데이터 값과 거기에 해당하는 현실 세계의 실제 값이 일치하는지 **신뢰**할 수 있기 때문이다.

</br>
    
#### 데이터베이스 접근의 장점

1. Controlling Redundancy(중복 제어)  

##### 중복성의 문제점
- 중복된 횟수만큼 반복해서 변경
- 새로운 데이터 추가시 양쪽 파일에 추가 즉 메모리 낭비 발생
- 동일한 데이터 포함하는 파일들에서 데이터 불일치 발생

##### Data normalization(데이터 정규화)

각 논리적 데이터는 데이터베이스 내에 오직 한번만 저장되는 것이 가장 이상적이다.  
그러므로 데이터베이스를 사용하면 이런 데이터 정규화를 지킬 수 있다.  

2. Restricting unauthorized access(비인가 접근 제한)

데이터베이스를 공유하는 경우에 **허가받은 사람만 데이터에 접근**가능하다.
접근의 유형을 검색과 갱신으로 구분해서 제어해야한다.  
  
이를 위해 DBMS는 보안과 권한 서브시스템을 가진다.

3. Providing persostent storage for program object(영속 저장)

- `Object-oriented DBMS`(객체지향 DBMS)는 지성 기억 공간을 제공한다.
- 데이터베이스에서는 **Impedance minmatch(임피던스 불일치)** 문제를 해결한다. 즉 데이터베이스시스템에서 제공하는 자료구조와 프로그램 언어에서 제공하는 자료구조와 불일치하는 문제를 객체지향언어와 호환성이 있는 자료구조를 제공하므로 이러한 불일치 문제를 해결한다.  

4. 효율적 질의 처리를 위한 저장 구조 제공

일반적으로 데이터베이스는 디스크에 저장되기 때문에, DBMS는 원흐는 레코드를 디스크에서 검색하는 시간을 줄이기 위해 특수한 자료구조와 탐색 기법을 제공해야한다.
- index
- buffering & caching module 제공


### 데이터베이스의 성능

데이터베이스의 성능인 디스크I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 시간이 결정되고 성능은 이 디스크헤더의 위치 이동없이 얼마나 많은 데이터를 한번에 기록하느냐에 따라 결정된다.  
  
그렇기 떄문에 순차 I/O가 랜덤 I/O 보다 빠를 수 밖에 없다. 현실에서 대부분 I/O 작업이 랜덤이고 데이터베이스 쿼리 튜닝은 이 랜덤 I/O 자체를 줄여주는 것이 목적이다.

</br>

## Data Model(데이터 모델)

사용자에게 데이터 저장구조의 세부사항을 은닉함으로써 어느 정도 **데이터 추상화**를 제공하는 도구이다. 이는 사용자에게 데이터를 잘 이해하는데 도움되는 필수적인 특징들만 강조하게 하는 역할을 하게 된다.(사용자의 편의를 위함)  
- Structure(구조)
	- 데이터 타입, 관계, 제약조건등
- Opeartions(연산)
	- retrieve(검색), update(갱신)등 기본연산 집합 포함한다.
    - 사용자 정의 연산도 포함하게 된다.
- Constraints(제약조건)

### 데이터 모델의 분류

- `Coceptual(개념)(High-level, semantic)`
- `Physical(물리적)(Low-level, internal)`
	- 데이터가 컴퓨터의 저장 장치, 특히 하드 디스크에 저장되는ㄱ에 대한 세부 사항을 명시하는 개념을 제공하한다.
- `Implementation(구현, 표현)`
	- 사용자들이 쉽게 이해할 수 있는 개념을 제공한다, 디스크상에서 데이터 저장 구조의 세부사항을 은폐하지만 컴퓨터 시스템에서 직접 구현될 수 있다.
    
    
## Three Schema Architecture

- Internal(Physical) schema - 내부스키마
	- 저장구조 세부사항 및 접근경로 등 물리적 데이터 모델 사용
- Conceptual(Logical) schema - 개념스키마
	- 전체 DB의 구조와 제약조건 기술
   	- 물리적 저장 구조 세부사항 은폐
- External(view level) schema - 외부 스키마
	- 사용자의 응용프로그램 View에 다양하게 서술된다.
    
<hr>

</br>

## 데이터베이스 설계(릴레이션 스키마 설계)

### 상향식 설계 방법론(Bottom-Up)

합성에 의한 설계라고도 불린다. 개별 애트리뷰트들 사이의 기본적인 관계를 고려하는 것으로 시작하요 릴레이션 스키마를 생성하는 방법론이다. 하지만 실제 상황에서 애트리뷰트쌍에 대한 이 같은 모든 이진 관계를 알고있는 것은 불가능하기때문에 잘 사용하지 않는다.  

### 하향식 설계 방법론(Top-Down)  

분석에 의한 설계라고도 불린다. 예를 들어 현실세계에서 자연스럽게 존재하는 애트리뷰트들(명세 청구서, 형식, 리포트 등)을 **그룹화**하여 만든 릴레이션들을 사용하여 설계를 시작하고, 그리고 나서 릴레이션들을 개별적, 통합적으로 분석하고 모든 바람직한 특성이 만톡될때까지 **분해**를 수행한다.  

> 설계 활동의 묵시적인 목적은 정보보존과 중복의 최소화 이다.

## 릴레이션 스키마를 설계하는 몇 가지 지침(Informal Guidelines)

- 애트리뷰트들의 의미(sementics)가 스키마에서 명확한지 확인해야한다.
- 튜플들에서 중복되는 값들을 줄인다.
- 튜플들에서 NULL값들을 줄인다.
- 가짜 튜플(spurious tuple)을 허용하지 않는다.  

### `지침 1`

**하나의 릴레이션 스키마는 하나 엔티티 타입 또는 관계 타입에 대응해야하한다**. 그래야 의미를 해석하기 쉽다.  

#### 투플에서 중복된 정보와 갱신 이상(Modification(update) anomalies)

스키마 설계의 목표 중 하나는 기본 릴레이션들(그리고 대응하는 파일들)에 의해 사용되는 저장공간을 최소화하는 것이다.  

##### 갱신 이상(Update anomalies)

![image](https://user-images.githubusercontent.com/33486820/57205257-43b4b680-6ff8-11e9-8340-a3a34ed8a4ad.png)

위의 예제 에서 EMPLOYEE 릴레이션과 PROJECT 릴레이션을 자연조인을 하여 지침 1의 규칙을 위반한 릴레이션 EMP_PROJ를 생성한다. 이때 (Ename, Pname, Plocation)애트리부트가 불필요한 중복이 발생한다. 이렇게 저장공간을 줄이기 위해 **기본 릴레이션을 자연 조인 저장** 하는 것은 갱신이상으로 불리는 문제점을 초래한다. 이 갱신이상은 **삽입이상**과 **수정이상**등으로 구분한다.

##### 삽입 이상

![image](https://user-images.githubusercontent.com/33486820/57205363-27fde000-6ff9-11e9-95b9-d53f150edb87.png)  

- 유형 1  
	 위의 예제는 EMPLOYEE와 DEPARTMENT(부서) 릴레이션을 자연 조인 해서 만든 릴레이션이다. 만약 여기에서 부서번호 5번인 사원을 추가한다 가정해보자. 그러면 기존의 EMPLOYEE 릴레이션인 경우 EMPLOYEE의 기본 애트리뷰터와 부서번호 5만 저장하면 된다. 하지만 위의 자연조인결과 릴레이션의 경우 일관성을 Dnumber, Dname, Dmgr_ssn 모두를 저장해야한다. 이는 불필요한 중복을 초례한다.
     
- 유형2  
	 사원이 없는 새 부서를 위 자연조인 릴레이션에 삽입하는 것은 어렵디. 만약 추가할려고 하면 사원에 관한 정보를 모두 NULL로 추가하고 삽입을 해야하는데 이는 **엔티티 무결성 위반** 즉 Primary Key인 Ssn은 NULL이 되어버리기에 위반하게 된다. 하지만 기본 릴레이션인 DEPARTMENT의 경우 그냥 추가 해주면 된다.  
     
##### 삭제 이상

만약 부서에 한 사원만 조재시 해당 사원을 삭제하면 부서도 사라져버리는 사태가 발생한다.  
##### 수정 이상  

만약 위의 EMP_DEPT에서 특정 부서에 관련된 애트리뷰트값을 갱신하면 예를들어 5번 부서의 관리자를 면경하면 위의 릴레이션에서 부소 5번의 Dmgr_ssn 애트리뷰트를 하나하나 찾아서 update해야하는 번거로움이 발생한다. 또 실패시 잘못된 데이터가 update될 위험이 있다.  

> 결론) 하나의 릴레이션은 하나의 엔티티 타입이나 관계 타입에 대응해야하고 그렇지 않을 시 갱신이상이 발생하여 데이터의 일관성을 유지하기 어렵게 만든다.  

</br>

### `지침 2`

릴레이션에서 삽입,삭제,수정 이상이 생기지 않도록 기본 릴레이션 스키마를 설계한다. 만약 어떤 이상이 존재하면 그것을 잘 이해하여 **데이터베이스를 수정하는 프로그램이들이 올바르게 동작 할 수 있도록 작성한다.**  


일반적으로 기본 릴레이션은 이상이 생기지 않게 하고, 대신 중요한 질의가 자주 참조하는 애트리뷰트들은 **조인을 이용하여 만든 뷰**를 사용하도록 한다.  

#### Tuple 의 NULL 값

여러 애트리뷰트 들이 모여 하나의 릴레이션을 생성할때 투플은 여러개의 NULL 애트리뷰트를 가질수 있게 된다. 이는 저장단계에서 공간을 낭비하게되고 조인연산, 애트리뷰트의 의미 파악에 어려움이 있다.  

널값의 해석
- 적용되지 않을때
- 값이 알려지지 않을때
- 아직 기록 되지 않았을때  

### `지침 3`  

**널값을 자주 가질 수 있는 애트리뷰트를 가능한 기본 릴레이션의 애트리뷰트로 포함하지 않는다.**  

예를 들어 EMPLOYEE 릴레이션에 개인 사무실을 가지고있는 사원을 위해 `office` 라는 애트리뷰트를 추가한다고 가정한다. 그런데 개인 사무실을 가지고 있는 사원은 전체 사원의 10퍼센트도 안된다. 만약 이를 무시하고 EMPLOYEE에 추가하게 될 경우 10%의 사원을 위해 남은 사원들 90% 의 `office` 애트리뷰트는 NULL이 될 것이다. 이는 저장 공간의 효율을 떨어 뜨리고 NULL값을 갖는 Join을 발생하게 되므로 차라리 **EMP_OFFICE**라는 새로운 릴레이션을 만들어 사무실이 있는 사원들의 정보를 따로 저장하는 것이 효율적이다.  

</br>

#### 가짜 투플(Spurious Tuple)

![image](https://user-images.githubusercontent.com/33486820/57206176-d9534480-6ffe-11e9-9e31-ef99b46ba305.png)

위의 두 릴레이션을 Join 할경우 양쪽에 있는 Plocation이라는 애트리뷰트가 단지 Plocation이 맞다는 이유로 Join이 되었고 이는 PK,FK(기본키,외래키) 관계가 아니기 떄문에 아래와 같이 가짜 투플을 생성하게 된다.  

![image](https://user-images.githubusercontent.com/33486820/57206216-128bb480-6fff-11e9-8ab0-a2bce2ed57ec.png)  

### `지침 4`  

가짜 투플들이 생성되지 않도록 하기 위해서, 적절하게 관련된(기본키, 외래키) 애트리뷰트를 가지고 **Equal Join**으로 조인할 수 있는 릴레이션 스키마를 설계한다.  
위의 예제에서 볼 수 있듯이 기본키,외래키 이외의 **Matching Attribute** 즉 대응되는 애트리뷰트를 가지지 않도록 해야한다.  


#### Non-Addictive or lossless Join Property

- lossless Join Property(무손실 조인 특성)  
	 조인 후에도 조인된 릴레이션의 인스턴스가 원래의 조인 연산 전의 릴레이션의 인스턴스인지 식별 가능한지 확인 하는 기능이다 .  
- Non-Addictive(비부가적 조인)
	 join시 원래 릴레이션 투플과 동일해야한다.


> 결론) 즉 큰 릴레이션을 잘게 쪼갤때 가짜 투플이 안생기게 설계해야한다. Lossless Join Property 가 안생기게 설계를 해야한다.  

위의 Non-Addictive성질이 보장될때 decomposition시 타협이 불가능하다. 반드시 해당 성질을 보장이 되어야한다. 하지만 함수적 종속성의 경우는 타협이 가능하다 왜냐하면 **성능 문제 때문에 어느정도 타협이 가능하다**.  

> 요약

|        | 내용|
|:-----|:---|
|지침 1  | 릴레이션 삽입이나 수정 시에 중복문제가 발생하기 때문에 하나의 릴레이션은 반드시 하나의 엔티티타입 또는 관계타입에 대응이 되어야한다|
|지침 2  | 릴레이션 스키마 설계시 반드시 지침 1에 위배 시키는 문제가 발생되지 않게 보장이 되어야한다.|
|지침 3  | NULL 값을 자주 포함하는 애트리뷰트를 기본 릴레이션에 추가하지 않는다. 대안으로 따로 릴레이션을 하나 만들어 NULL값을 적게 하여 저장 효율을 높인다.|
|지침 4  | Lossless Join Propery 즉 Non-Addictive 성질을 만족하게 릴레이션을 설계해야한다|

</br>

<hr>

## 함수적 종속성(Functional Dependencies)

함수적 종속성은 애트리 뷰트들의 두 개의 집합 사이의 제약 조건이다.  

> 정의

전체 릴레이션 스키마 R의 애트리뷰트들의 부분집합인 X와 Y 사이의 **함수적 종속성**(X -> Y)은 릴레이션 스키마 R의 릴레이션 상태 r을 구성할 수 있는 가능한 투플들에 대한 **제약조건**을 지정하는 것이다. 여기서 제약조건은 r의 임의의 두 투플 t1, t2에 대해 `t1[X] = t2[X]` 이면 반드시 `t1[Y] = t2[Y]`이어야 한다는 것이다.  

X값만 알면 Y값을 알 수 있다(e.g. 사원의 ssn(사회보장번호)를 알면 Ename, Birthday등 알수 있다)  

> 참고) Functionally == Uniquely  

`t1[X] = t2[X]` 이면 `t1[Y] = t2[Y]` 일때에 한하여 X가 Y를 함수적으로 결정한다고 한다.  

- 만약 임의의 릴레이션 인스턴스 r(R)에서 주어진 X값을 갖는 투플이 두개 이상 존재하지 않는다는 제약조건이 있으면,즉 X 가 R의 후보키이면(Key 제약조건에 의해 중복되는 Tuple 이 없다는 것을 보장된다.) R의 애트리뷰트들의 어떤 부분집합 Y에 대해서도 X->Y가 성립된다. 만약 X가 R의 후보키면 X -> R 이라고한다(어떤 애트리뷰트 든 성립하기에)
	- e.g.) ssn은 P.K, phone_number 은 후보키라 했을때 phone_number는 EMPLOYEE의 전체 투플들을 유일하게 구분가능하며 중복이 없기 때문에 후보키가 될 수 있고 이는 `phone_number -> EMPLOYEE`가 성립 된 다라고 말할 수 있다.  
    
- R에 X -> Y 가 있다고 해서 R에 Y -> X 가 있는 것은 아니다.(역 성립 x)
	- e.g.) Ssn -> Ename 이지만 Ename -> Ssn은 안된다(동명이인이 존재하기 때문)
    
> 결론) 릴레이션 R에서 두 애트리뷰트 X,Y에 대해 X -> Y가 성립이 될려면 X가 전체 R의 투플에 대해 'uniquely determin' 이 보장된다. 즉 X 가 R의 SuperKey(or Key) 일때 X -> Y 가 성립 된다고 할 수 있고 만약 X 가 후보키라면 X -> R이라고도 할 수 있다.  

</br>

<hr>

## 릴레이션들의 정규화

**데이터의 정규화**

1. 중복을 최소화
2. 삽입, 삭제 수정 이상을 최소화  
를 목적으로 함수적 종속성과 기본키를 기반으로 , 주어진 릴레이션 스키마를 분석하는 과정이다. 한마디로 성공적인 설계를 위해 "제거" 와 "정제" 과정으로 릴레이션상의 악 영향을 끼치는 애트리뷰트 들을 적절히 나누어 작은 릴레이션으로 분해 하는 작업이다.  


### 분해 과정시 정규화의 필요성 판단  

- 가짜 투플로 인해 분해 후에 생성된 릴레이션 스키마에 대해서 발생하지 않는 것을 보장하는 **Non-Addictive join** 또는 **lossless join property** 가 지켜지는 지를 판단해야한다.  
- 함수적 종속성이 분해 후 생성 된 릴레이션들의 일부에서 반드시 표현된다는 **종속성 보존 특성**이 만족 되는지 판단해야한다.  

위의 **Non-Addictive join** 또는 **lossless join property** 는 반드시 지켜져야하지만 **종속성보존 특성**은 성능문제 때문에 어느정도 타협이 가능하다. 이는 데이터이스 설계짜가 릴레이션을 최상의 수준의 정규형으로 정규화 할 필요가 없는 것이다. (e.g.2NF의 상태로 일부러 둘 수 있다)하지만 이는 이상 현상을 처리해야하는 비용을 발생 시킨다.  

### 제 1 정규형  

애트리뷰트의 도메인이 오직 **원자값** 만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야한다. 즉 **복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트를 허용하지 않는 릴레이션 형태**를 말한다.  

![image](https://user-images.githubusercontent.com/33486820/57210330-4541a700-7017-11e9-8a35-982a9806118b.png)

> 참고) Mongo DB에서는 sub tuple 을 넣어 한 튜플이 여러개의 애트리뷰트 값을 즉 중첩릴레이션을 갖게 허용할 수 있다. 

</br>

### 제 2 정규형  

모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 **완전 함수적 종속**이면 제 2 정규형을 만족한다. 

#### 완전 함수적 종속(Full Functional Dependency)  

릴레이션 R에서 X -> Y에서 X의 애트리뷰트 집합중 하나만 제거를 해도 X -> Y가 성립되지 경우를 말하고 이 와 반대로 성립이 되면 이를 **Partial Dependency** 부분종속성이라한다.  

> 결론) X -> Y에서 X의 애트리뷰트 그 어느것도 제거 했을때 X -> Y 가 깨지는 경우 제 2 정규형을 만족한다 볼 수 있다.  


![image](https://user-images.githubusercontent.com/33486820/57211451-4aa0f080-701b-11e9-9476-056a24c95f13.png)  

- 정의. 릴레이션 스키마 R의 모든 **비주요 애트리뷰트 A가 R의 어떤 키에도 부분적으로 종속하지 않으면** R은 제 2 정규형이다.  


</br>

### 제 3 정규형  

어떠한 비주요 애트리뷰트도 기본키에 대해서 **이행적으로 종속되지 않으면** 제 3 정규형을 만족한다고 볼 수 있다.  

#### 이행적 종속성(Transitive dependency)  

릴레이션 스키마 R에서 후보키가 아니고 어떤 키의 부분집합도 아닌 애트리뷰트들의 집합 Z가 존재하여 X -> Z, Z -> Y 가 만족될때 X -> Y의 함수적 종속성을 만족한다.  

![image](https://user-images.githubusercontent.com/33486820/57211988-365df300-701d-11e9-9c03-7623e0e74644.png)  

위의 EMP_DEPT 릴렐이션에서 Ssn -> Dnumber가 성립이 되고 Dnumber -> Dmgr_ssn이 성립이 되므로 Ssn -> Dmgr_ssn이 이행적으로 종속된다.  

> Q) 근데 이게 왜 문제가 되냐?  

EMP_DEPT 릴레이션에서 Dnumber가 키가 아니기 때문에 Dmgr_ssn이 Dnumber에 종속하는 것은 바랍직하지 않다. ( Key도 아닌 것이 함수적 종속성을 만족시키고 있어 이는 함수적 종속성의 성질을 위배하고 있기 때문이다)  

![image](https://user-images.githubusercontent.com/33486820/57212310-44f8da00-701e-11e9-92fe-ac8e6c30b7b3.png)

- 정의. 릴레이션 스키마 R의 모든 함수적 종속성 X -> A에 대해서 
	- X가 R의 **슈퍼키** 이거나
    - A가 R의 **주요 애트리뷰트** 이면
R은 제 3 정규형이다.  


</br>

### BCNF(Boyce-Codd) 정규화  

여러 후보 키가 존재하는 릴레이션에 해당하는 정규화의 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다.  
그리고 BCNF 릴레이션은 제3정규형이지만, 제3정규형은 반드시 BCNF가 아니다.  

> 예제 

LOTS1A라는 토지관련 릴레이션이 있다. 이떄 Contry_name은 단 두개 A도시, B도시만 있고 각 A도시의 토지 면적(Area)는 0.5,0.6, ...1.9, 1.0에이커에 속하고 B도시에는 1.1, 1.2 ... 1.9, 2.0에이커에 속한다고 할때 Area 애트리뷰트만 알면 Coutry_name을 알수 있기에 `Area -> Country_name`이라고 할수 있다. 이떄 Country_name은 주요 애트리뷰트이기 때문에 제3정규형을 만족시킨다.  

이때 BCNF는 LOTS1A 릴레이션의 중복을 줄이기 위해 LOST1AY(<U>Area</U>, Country_name) 이라는 릴레이션을 추가하여 분해하도록 하는 더 강력한 정규형이다.  

- 정의 **릴레이션 스키마 R에서, 모든 의미있는 함수적 종속성 X -> A를 만족할 때마다 X는 R의 슈퍼키라면 B는 BCNF이다**  

#### 제3정규형과 BCNF의 차이

실제로 대부분의 제3정규형 릴레이션 스키마는 또한 BCNF 릴레이션 스키마다. 하지만
릴레이션 스키마 R의 종속성 **X -> A에서 X가 슈퍼키가 아니고 A가 주요 애트리뷰트인 경우에만 제3 정규형이고 BCNF는아니다.**

#### 제3정규형이지만 BCNF가 아닌 릴레이션 TEACH  

![image](https://user-images.githubusercontent.com/33486820/57238021-616b3580-7063-11e9-9262-e2f614c95aad.png)  

- BCNF를 만족시키기 위해 두개의 릴레이션 스키마로 분해 




#### 관계 데이터베이스 설계의 목표

각 정규형은 그의 선행 정규형 보다 더 엄격한 조건을 갖는다.  

- 모든 제2정규형 릴레이션은 제1정규형을 갖는다.
- 모든 제3정규형 릴레이션은 제2정규형을 갖는다.
- 모든 BCNF 정규형 릴레이션은 제3정규형을 갖는다.

수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.  







































